/**
 * Todo Manager Service
 *
 * Syncs and tracks todo lists generated by the Claude Agent SDK.
 * The SDK automatically creates todos using its built-in TodoWrite tool.
 *
 * Pattern based on Claude Agent SDK documentation:
 * - SDK generates todos automatically for multi-step tasks
 * - Intercept TodoWrite tool events from the agent stream
 * - Sync todos to Azure SQL database
 * - Emit real-time updates via WebSocket to frontend
 *
 * @module services/todo/TodoManager
 */

import { Server as SocketServer } from 'socket.io';
import crypto from 'crypto';
import { getDatabase } from '../../config/database';
import {
  Todo,
  TodoStatus,
  TodoCreateRequest,
  TodoCreatedEvent,
  TodoUpdatedEvent,
  TodoCompletedEvent,
} from '../../types/todo.types';

/**
 * TodoManager class
 *
 * Manages automatic todo list generation and tracking
 */
export class TodoManager {
  private io: SocketServer;
  private static instance: TodoManager | null = null;

  private constructor(io: SocketServer) {
    this.io = io;
  }

  /**
   * Get singleton instance of TodoManager
   *
   * @param io - Socket.IO server instance
   * @returns TodoManager instance
   */
  public static getInstance(io?: SocketServer): TodoManager {
    if (!TodoManager.instance) {
      if (!io) {
        throw new Error('Socket.IO server is required to initialize TodoManager');
      }
      TodoManager.instance = new TodoManager(io);
    }
    return TodoManager.instance;
  }

  /**
   * Sync todos from Agent SDK's TodoWrite tool
   *
   * The SDK automatically creates todos during agent execution.
   * This method intercepts those todos and syncs them to our database.
   *
   * @param sessionId - Session ID
   * @param sdkTodos - Todos from SDK's TodoWrite tool
   * @returns Array of synced todos
   */
  public async syncTodosFromSDK(
    sessionId: string,
    sdkTodos: Array<{ content: string; status: TodoStatus; activeForm: string }>
  ): Promise<Todo[]> {
    console.log(`[TodoManager] Syncing ${sdkTodos.length} todos from SDK for session ${sessionId}`);

    // Extract just the content strings
    const steps = sdkTodos.map(todo => todo.content);

    // Create todos in database
    const todos = await this.createTodosFromSteps(sessionId, steps);

    // Emit event to client
    const event: TodoCreatedEvent = {
      sessionId,
      todos,
    };
    this.io.to(sessionId).emit('todo:created', event);

    console.log(`[TodoManager] ✅ Synced ${todos.length} todos from SDK`);

    return todos;
  }

  /**
   * Create a single todo manually
   *
   * @param request - Todo creation request
   * @returns Created todo
   */
  public async createManualTodo(request: TodoCreateRequest): Promise<Todo> {
    const { sessionId, content, activeForm, order } = request;

    const db = getDatabase();
    if (!db) {
      throw new Error('Database connection not available');
    }

    const todoId = this.generateTodoId();
    const now = new Date();

    // Determine order if not provided
    let todoOrder = order;
    if (todoOrder === undefined) {
      const result = await db.request()
        .input('session_id', sessionId)
        .query('SELECT MAX([order]) as maxOrder FROM todos WHERE session_id = @session_id');

      todoOrder = (result.recordset[0]?.maxOrder ?? -1) + 1;
    }

    await db.request()
      .input('id', todoId)
      .input('session_id', sessionId)
      .input('content', content)
      .input('activeForm', activeForm)
      .input('status', 'pending')
      .input('order', todoOrder)
      .input('created_at', now)
      .query(`
        INSERT INTO todos (id, session_id, content, activeForm, status, [order], created_at)
        VALUES (@id, @session_id, @content, @activeForm, @status, @order, @created_at)
      `);

    const todo: Todo = {
      id: todoId,
      session_id: sessionId,
      content,
      activeForm,
      status: 'pending',
      order: todoOrder ?? 0,
      created_at: now,
    };

    // Emit event
    this.io.to(sessionId).emit('todo:created', { sessionId, todos: [todo] });

    return todo;
  }

  /**
   * Mark a todo as in progress
   *
   * @param sessionId - Session ID
   * @param todoId - Todo ID
   */
  public async markInProgress(sessionId: string, todoId: string): Promise<void> {
    await this.updateTodoStatus(sessionId, todoId, 'in_progress');
  }

  /**
   * Mark a todo as completed or failed
   *
   * @param sessionId - Session ID
   * @param todoId - Todo ID
   * @param success - Whether the task succeeded
   */
  public async markCompleted(sessionId: string, todoId: string, success: boolean): Promise<void> {
    const status: TodoStatus = success ? 'completed' : 'failed';
    await this.updateTodoStatus(sessionId, todoId, status);

    // Emit completion event
    const event: TodoCompletedEvent = {
      todoId,
      sessionId,
      status,
      completedAt: new Date(),
    };
    this.io.to(sessionId).emit('todo:completed', event);
  }

  /**
   * Get all todos for a session
   *
   * @param sessionId - Session ID
   * @returns Array of todos
   */
  public async getTodosBySession(sessionId: string): Promise<Todo[]> {
    const db = getDatabase();
    if (!db) {
      throw new Error('Database connection not available');
    }

    const result = await db.request()
      .input('session_id', sessionId)
      .query(`
        SELECT id, session_id, content, activeForm, status, [order], created_at, started_at, completed_at
        FROM todos
        WHERE session_id = @session_id
        ORDER BY [order] ASC
      `);

    return result.recordset.map((row) => ({
      id: row.id,
      session_id: row.session_id,
      content: row.content,
      activeForm: row.activeForm,
      status: row.status as TodoStatus,
      order: row.order,
      created_at: row.created_at,
      started_at: row.started_at,
      completed_at: row.completed_at,
    }));
  }

  /**
   * Update todo status
   *
   * @param sessionId - Session ID
   * @param todoId - Todo ID
   * @param status - New status
   */
  private async updateTodoStatus(sessionId: string, todoId: string, status: TodoStatus): Promise<void> {
    const db = getDatabase();
    if (!db) {
      throw new Error('Database connection not available');
    }

    const now = new Date();
    const startedAtUpdate = status === 'in_progress' ? ', started_at = @now' : '';
    const completedAtUpdate = (status === 'completed' || status === 'failed') ? ', completed_at = @now' : '';

    await db.request()
      .input('id', todoId)
      .input('status', status)
      .input('now', now)
      .query(`
        UPDATE todos
        SET status = @status${startedAtUpdate}${completedAtUpdate}
        WHERE id = @id
      `);

    // Emit update event
    const event: TodoUpdatedEvent = {
      todoId,
      sessionId,
      status,
      completedAt: (status === 'completed' || status === 'failed') ? now : undefined,
    };
    this.io.to(sessionId).emit('todo:updated', event);

    console.log(`[TodoManager] Todo ${todoId} → ${status}`);
  }

  /**
   * Create todos from steps array
   *
   * @param sessionId - Session ID
   * @param steps - Array of step descriptions
   * @returns Array of created todos
   */
  private async createTodosFromSteps(sessionId: string, steps: string[]): Promise<Todo[]> {
    const db = getDatabase();
    if (!db) {
      throw new Error('Database connection not available');
    }

    const todos: Todo[] = [];
    const now = new Date();

    for (let i = 0; i < steps.length; i++) {
      const step = steps[i];
      if (!step) continue; // Skip undefined steps

      const todoId = this.generateTodoId();

      // Generate active form (present continuous)
      const activeForm = this.toActiveForm(step);

      await db.request()
        .input('id', todoId)
        .input('session_id', sessionId)
        .input('content', step)
        .input('activeForm', activeForm)
        .input('status', 'pending')
        .input('order', i)
        .input('created_at', now)
        .query(`
          INSERT INTO todos (id, session_id, content, activeForm, status, [order], created_at)
          VALUES (@id, @session_id, @content, @activeForm, @status, @order, @created_at)
        `);

      todos.push({
        id: todoId,
        session_id: sessionId,
        content: step,
        activeForm,
        status: 'pending',
        order: i,
        created_at: now,
      });
    }

    return todos;
  }


  /**
   * Convert imperative form to present continuous (active form)
   *
   * @param imperative - Imperative form (e.g., "Create customer")
   * @returns Present continuous form (e.g., "Creating customer")
   */
  private toActiveForm(imperative: string): string {
    // Basic conversion rules
    const verbMap: Record<string, string> = {
      'create': 'creating',
      'update': 'updating',
      'delete': 'deleting',
      'fetch': 'fetching',
      'query': 'querying',
      'validate': 'validating',
      'analyze': 'analyzing',
      'generate': 'generating',
      'send': 'sending',
      'process': 'processing',
    };

    const firstWord = imperative.split(' ')[0]?.toLowerCase() || imperative.toLowerCase();
    const rest = imperative.substring(firstWord.length).trim();

    const activeVerb = verbMap[firstWord] || `${firstWord}ing`;
    return `${activeVerb.charAt(0).toUpperCase()}${activeVerb.slice(1)} ${rest}`;
  }

  /**
   * Generate unique todo ID (GUID)
   *
   * @returns UUID v4 GUID for todo ID
   */
  private generateTodoId(): string {
    return crypto.randomUUID();
  }
}

/**
 * Get singleton instance of TodoManager
 *
 * @param io - Socket.IO server instance (required on first call)
 * @returns TodoManager instance
 */
export function getTodoManager(io?: SocketServer): TodoManager {
  return TodoManager.getInstance(io);
}
